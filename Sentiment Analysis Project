{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/IamAnindyaSharma/Prod-Projects/blob/main/Welcome_To_Colab.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "from google.colab import files\n",
        "\n",
        "# Upload PDFs\n",
        "uploaded = files.upload()"
      ],
      "metadata": {
        "id": "iau3HTixnPO2",
        "outputId": "c00d1b81-9750-444b-9fc7-f6a5c1ef5d32",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 216
        }
      },
      "execution_count": 17,
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<IPython.core.display.HTML object>"
            ],
            "text/html": [
              "\n",
              "     <input type=\"file\" id=\"files-0491d6c6-23f8-457e-88dc-fd356aa402bc\" name=\"files[]\" multiple disabled\n",
              "        style=\"border:none\" />\n",
              "     <output id=\"result-0491d6c6-23f8-457e-88dc-fd356aa402bc\">\n",
              "      Upload widget is only available when the cell has been executed in the\n",
              "      current browser session. Please rerun this cell to enable.\n",
              "      </output>\n",
              "      <script>// Copyright 2017 Google LLC\n",
              "//\n",
              "// Licensed under the Apache License, Version 2.0 (the \"License\");\n",
              "// you may not use this file except in compliance with the License.\n",
              "// You may obtain a copy of the License at\n",
              "//\n",
              "//      http://www.apache.org/licenses/LICENSE-2.0\n",
              "//\n",
              "// Unless required by applicable law or agreed to in writing, software\n",
              "// distributed under the License is distributed on an \"AS IS\" BASIS,\n",
              "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
              "// See the License for the specific language governing permissions and\n",
              "// limitations under the License.\n",
              "\n",
              "/**\n",
              " * @fileoverview Helpers for google.colab Python module.\n",
              " */\n",
              "(function(scope) {\n",
              "function span(text, styleAttributes = {}) {\n",
              "  const element = document.createElement('span');\n",
              "  element.textContent = text;\n",
              "  for (const key of Object.keys(styleAttributes)) {\n",
              "    element.style[key] = styleAttributes[key];\n",
              "  }\n",
              "  return element;\n",
              "}\n",
              "\n",
              "// Max number of bytes which will be uploaded at a time.\n",
              "const MAX_PAYLOAD_SIZE = 100 * 1024;\n",
              "\n",
              "function _uploadFiles(inputId, outputId) {\n",
              "  const steps = uploadFilesStep(inputId, outputId);\n",
              "  const outputElement = document.getElementById(outputId);\n",
              "  // Cache steps on the outputElement to make it available for the next call\n",
              "  // to uploadFilesContinue from Python.\n",
              "  outputElement.steps = steps;\n",
              "\n",
              "  return _uploadFilesContinue(outputId);\n",
              "}\n",
              "\n",
              "// This is roughly an async generator (not supported in the browser yet),\n",
              "// where there are multiple asynchronous steps and the Python side is going\n",
              "// to poll for completion of each step.\n",
              "// This uses a Promise to block the python side on completion of each step,\n",
              "// then passes the result of the previous step as the input to the next step.\n",
              "function _uploadFilesContinue(outputId) {\n",
              "  const outputElement = document.getElementById(outputId);\n",
              "  const steps = outputElement.steps;\n",
              "\n",
              "  const next = steps.next(outputElement.lastPromiseValue);\n",
              "  return Promise.resolve(next.value.promise).then((value) => {\n",
              "    // Cache the last promise value to make it available to the next\n",
              "    // step of the generator.\n",
              "    outputElement.lastPromiseValue = value;\n",
              "    return next.value.response;\n",
              "  });\n",
              "}\n",
              "\n",
              "/**\n",
              " * Generator function which is called between each async step of the upload\n",
              " * process.\n",
              " * @param {string} inputId Element ID of the input file picker element.\n",
              " * @param {string} outputId Element ID of the output display.\n",
              " * @return {!Iterable<!Object>} Iterable of next steps.\n",
              " */\n",
              "function* uploadFilesStep(inputId, outputId) {\n",
              "  const inputElement = document.getElementById(inputId);\n",
              "  inputElement.disabled = false;\n",
              "\n",
              "  const outputElement = document.getElementById(outputId);\n",
              "  outputElement.innerHTML = '';\n",
              "\n",
              "  const pickedPromise = new Promise((resolve) => {\n",
              "    inputElement.addEventListener('change', (e) => {\n",
              "      resolve(e.target.files);\n",
              "    });\n",
              "  });\n",
              "\n",
              "  const cancel = document.createElement('button');\n",
              "  inputElement.parentElement.appendChild(cancel);\n",
              "  cancel.textContent = 'Cancel upload';\n",
              "  const cancelPromise = new Promise((resolve) => {\n",
              "    cancel.onclick = () => {\n",
              "      resolve(null);\n",
              "    };\n",
              "  });\n",
              "\n",
              "  // Wait for the user to pick the files.\n",
              "  const files = yield {\n",
              "    promise: Promise.race([pickedPromise, cancelPromise]),\n",
              "    response: {\n",
              "      action: 'starting',\n",
              "    }\n",
              "  };\n",
              "\n",
              "  cancel.remove();\n",
              "\n",
              "  // Disable the input element since further picks are not allowed.\n",
              "  inputElement.disabled = true;\n",
              "\n",
              "  if (!files) {\n",
              "    return {\n",
              "      response: {\n",
              "        action: 'complete',\n",
              "      }\n",
              "    };\n",
              "  }\n",
              "\n",
              "  for (const file of files) {\n",
              "    const li = document.createElement('li');\n",
              "    li.append(span(file.name, {fontWeight: 'bold'}));\n",
              "    li.append(span(\n",
              "        `(${file.type || 'n/a'}) - ${file.size} bytes, ` +\n",
              "        `last modified: ${\n",
              "            file.lastModifiedDate ? file.lastModifiedDate.toLocaleDateString() :\n",
              "                                    'n/a'} - `));\n",
              "    const percent = span('0% done');\n",
              "    li.appendChild(percent);\n",
              "\n",
              "    outputElement.appendChild(li);\n",
              "\n",
              "    const fileDataPromise = new Promise((resolve) => {\n",
              "      const reader = new FileReader();\n",
              "      reader.onload = (e) => {\n",
              "        resolve(e.target.result);\n",
              "      };\n",
              "      reader.readAsArrayBuffer(file);\n",
              "    });\n",
              "    // Wait for the data to be ready.\n",
              "    let fileData = yield {\n",
              "      promise: fileDataPromise,\n",
              "      response: {\n",
              "        action: 'continue',\n",
              "      }\n",
              "    };\n",
              "\n",
              "    // Use a chunked sending to avoid message size limits. See b/62115660.\n",
              "    let position = 0;\n",
              "    do {\n",
              "      const length = Math.min(fileData.byteLength - position, MAX_PAYLOAD_SIZE);\n",
              "      const chunk = new Uint8Array(fileData, position, length);\n",
              "      position += length;\n",
              "\n",
              "      const base64 = btoa(String.fromCharCode.apply(null, chunk));\n",
              "      yield {\n",
              "        response: {\n",
              "          action: 'append',\n",
              "          file: file.name,\n",
              "          data: base64,\n",
              "        },\n",
              "      };\n",
              "\n",
              "      let percentDone = fileData.byteLength === 0 ?\n",
              "          100 :\n",
              "          Math.round((position / fileData.byteLength) * 100);\n",
              "      percent.textContent = `${percentDone}% done`;\n",
              "\n",
              "    } while (position < fileData.byteLength);\n",
              "  }\n",
              "\n",
              "  // All done.\n",
              "  yield {\n",
              "    response: {\n",
              "      action: 'complete',\n",
              "    }\n",
              "  };\n",
              "}\n",
              "\n",
              "scope.google = scope.google || {};\n",
              "scope.google.colab = scope.google.colab || {};\n",
              "scope.google.colab._files = {\n",
              "  _uploadFiles,\n",
              "  _uploadFilesContinue,\n",
              "};\n",
              "})(self);\n",
              "</script> "
            ]
          },
          "metadata": {}
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Saving q2fy21-transcript.pdf to q2fy21-transcript.pdf\n",
            "Saving Q2FY23_Transcript.pdf to Q2FY23_Transcript.pdf\n",
            "Saving Q3FY19-Transcript.pdf to Q3FY19-Transcript.pdf\n",
            "Saving Q3FY20-23-transcript.pdf to Q3FY20-23-transcript.pdf\n",
            "Saving Q3FY20-Transcript.pdf to Q3FY20-Transcript.pdf\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "!pip install PyMuPDF\n",
        "\n",
        "import fitz  # PyMuPDF\n",
        "import json\n",
        "import os\n",
        "\n",
        "# Function to extract text from a single PDF\n",
        "def extract_text_from_pdf(pdf_path):\n",
        "    text = \"\"\n",
        "    with fitz.open(pdf_path) as pdf:\n",
        "        for page_num in range(pdf.page_count):\n",
        "            page = pdf[page_num]\n",
        "            text += page.get_text()\n",
        "    return text\n",
        "\n",
        "# Loop through uploaded PDFs and save the extracted text in individual text files\n",
        "text_data = {}\n",
        "for pdf_name in uploaded.keys():\n",
        "    text = extract_text_from_pdf(pdf_name)\n",
        "    text_data[pdf_name] = text\n",
        "    # Save each PDF text to a separate text file\n",
        "    with open(f'{pdf_name}.txt', 'w') as txt_file:\n",
        "        txt_file.write(text)\n",
        "    print(f\"Text from {pdf_name} saved to {pdf_name}.txt\")\n"
      ],
      "metadata": {
        "id": "nZzfh-WyottJ",
        "outputId": "1580ecf9-b046-43a6-ecb8-dd030f4411dc",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "execution_count": 18,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Requirement already satisfied: PyMuPDF in /usr/local/lib/python3.10/dist-packages (1.24.13)\n",
            "Text from q2fy21-transcript.pdf saved to q2fy21-transcript.pdf.txt\n",
            "Text from Q2FY23_Transcript.pdf saved to Q2FY23_Transcript.pdf.txt\n",
            "Text from Q3FY19-Transcript.pdf saved to Q3FY19-Transcript.pdf.txt\n",
            "Text from Q3FY20-23-transcript.pdf saved to Q3FY20-23-transcript.pdf.txt\n",
            "Text from Q3FY20-Transcript.pdf saved to Q3FY20-Transcript.pdf.txt\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "!pip install nltk\n",
        "\n",
        "import nltk\n",
        "import json\n",
        "import os\n",
        "from datetime import datetime\n",
        "\n",
        "nltk.download('punkt')\n",
        "\n",
        "# Define metadata information for each file\n",
        "# You can update these details as needed for your project\n",
        "metadata_info = {\n",
        "    \"/content/q2fy21-transcript.pdf.txt\": {\"company_name\": \"Company A\", \"ticker_symbol\": \"CMPA\", \"date\": \"2023-07-15\"},\n",
        "    \"/content/Q2FY23_Transcript.pdf.txt\": {\"company_name\": \"Company B\", \"ticker_symbol\": \"CMPB\", \"date\": \"2023-07-16\"},\n",
        "    \"/content/Q3FY19-Transcript.pdf.txt\": {\"company_name\": \"Company C\", \"ticker_symbol\": \"CMPC\", \"date\": \"2023-07-17\"},\n",
        "    \"/content/Q3FY20-23-transcript.pdf.txt\": {\"company_name\": \"Company D\", \"ticker_symbol\": \"CMPD\", \"date\": \"2023-07-18\"},\n",
        "    \"/content/Q3FY20-Transcript.pdf.txt\": {\"company_name\": \"Company E\", \"ticker_symbol\": \"CMPE\", \"date\": \"2023-07-19\"},\n",
        "}\n",
        "\n",
        "# Initialize list to hold JSON data for all transcripts\n",
        "json_data = []\n",
        "\n",
        "# Process each text file in the metadata dictionary\n",
        "for file_name, meta in metadata_info.items():\n",
        "    # Load text from each file\n",
        "    with open(file_name, 'r') as file:\n",
        "        text = file.read()\n",
        "\n",
        "    # Tokenize text into sentences\n",
        "    sentences = nltk.sent_tokenize(text)\n",
        "\n",
        "    # Extract metadata\n",
        "    date_obj = datetime.strptime(meta[\"date\"], \"%Y-%m-%d\")\n",
        "    company_data = {\n",
        "        \"Company Name\": meta[\"company_name\"],\n",
        "        \"Date\": meta[\"date\"],\n",
        "        \"Month\": date_obj.strftime(\"%B\"),\n",
        "        \"Year\": date_obj.year,\n",
        "        \"Ticker Symbol\": meta[\"ticker_symbol\"],\n",
        "        \"Array of Sentences\": sentences\n",
        "    }\n",
        "\n",
        "    # Append the structured data to JSON list\n",
        "    json_data.append(company_data)\n",
        "\n",
        "# Save the complete data to a JSON file\n",
        "with open('transcripts_with_metadata2.json', 'w') as json_file:\n",
        "    json.dump(json_data, json_file, indent=4)\n",
        "\n",
        "print(\"All text files converted to JSON format with metadata and saved as transcripts_with_metadata.json\")\n",
        "\n",
        "\n"
      ],
      "metadata": {
        "id": "MZVlqdFvo9Qo",
        "outputId": "f82c2ea1-e783-4614-b789-dfb3526c8f21",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "execution_count": 19,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Requirement already satisfied: nltk in /usr/local/lib/python3.10/dist-packages (3.8.1)\n",
            "Requirement already satisfied: click in /usr/local/lib/python3.10/dist-packages (from nltk) (8.1.7)\n",
            "Requirement already satisfied: joblib in /usr/local/lib/python3.10/dist-packages (from nltk) (1.4.2)\n",
            "Requirement already satisfied: regex>=2021.8.3 in /usr/local/lib/python3.10/dist-packages (from nltk) (2024.9.11)\n",
            "Requirement already satisfied: tqdm in /usr/local/lib/python3.10/dist-packages (from nltk) (4.66.6)\n",
            "All text files converted to JSON format with metadata and saved as transcripts_with_metadata.json\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "[nltk_data] Downloading package punkt to /root/nltk_data...\n",
            "[nltk_data]   Package punkt is already up-to-date!\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "import pandas as pd\n",
        "import json\n",
        "\n",
        "# Load the JSON data\n",
        "with open('transcripts_with_metadata.json', 'r') as json_file:\n",
        "    json_data = json.load(json_file)\n",
        "\n",
        "# Convert JSON to DataFrame\n",
        "df = pd.json_normalize(json_data, record_path='Array of Sentences',\n",
        "                       meta=['Company Name', 'Date', 'Month', 'Year', 'Ticker Symbol'],\n",
        "                       errors='ignore')\n",
        "\n",
        "# Rename the column from Array of Sentences to Sentence for clarity\n",
        "df = df.rename(columns={0: 'Sentence'})\n",
        "\n",
        "# Display the DataFrame\n",
        "print(df.head)\n"
      ],
      "metadata": {
        "id": "I8sm5LB4qdqJ",
        "outputId": "60400ebd-e746-4e5d-f682-d7fa161be7b4",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "execution_count": 7,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "<bound method NDFrame.head of                                                Sentence Company Name  \\\n",
            "0      \\n \\nPage 1 of 22 \\n \\n \\n   Kotak Mahindra B...    Company A   \n",
            "1     – PRESIDENT – GROUP TREASURY \\nMR. VIRAT DIWAN...    Company A   \n",
            "2     Actual results may vary significantly from the...    Company A   \n",
            "3     These risks and uncertainties include \\nthe ef...    Company A   \n",
            "4     Kotak Mahindra does not \\nundertake to update ...    Company A   \n",
            "...                                                 ...          ...   \n",
            "2578  Let's pray for that and let's all of us work h...    Company E   \n",
            "2579         Thank you very much, ladies and gentlemen.    Company E   \n",
            "2580                            Moderator: \\nThank you.    Company E   \n",
            "2581  Ladies and gentlemen, on behalf of Kotak Mahin...    Company E   \n",
            "2582  Thank you all for joining us and you may now d...    Company E   \n",
            "\n",
            "            Date Month  Year Ticker Symbol  \n",
            "0     2023-07-15  July  2023          CMPA  \n",
            "1     2023-07-15  July  2023          CMPA  \n",
            "2     2023-07-15  July  2023          CMPA  \n",
            "3     2023-07-15  July  2023          CMPA  \n",
            "4     2023-07-15  July  2023          CMPA  \n",
            "...          ...   ...   ...           ...  \n",
            "2578  2023-07-19  July  2023          CMPE  \n",
            "2579  2023-07-19  July  2023          CMPE  \n",
            "2580  2023-07-19  July  2023          CMPE  \n",
            "2581  2023-07-19  July  2023          CMPE  \n",
            "2582  2023-07-19  July  2023          CMPE  \n",
            "\n",
            "[2583 rows x 6 columns]>\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# Load the DataFrame from the JSON data\n",
        "import pandas as pd\n",
        "\n",
        "# Replace with the path to your JSON file if needed\n",
        "df = pd.read_json('transcripts_with_metadata2.json')\n",
        "\n",
        "# Check column names\n",
        "print(\"Column Names:\", df.columns)\n",
        "print(df.head())\n"
      ],
      "metadata": {
        "id": "zex0daA0qxU5",
        "outputId": "76d2d421-f169-4700-95e9-c0d1ad478001",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "execution_count": 20,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Column Names: Index(['Company Name', 'Date', 'Month', 'Year', 'Ticker Symbol',\n",
            "       'Array of Sentences'],\n",
            "      dtype='object')\n",
            "  Company Name       Date Month  Year Ticker Symbol  \\\n",
            "0    Company A 2023-07-15  July  2023          CMPA   \n",
            "1    Company B 2023-07-16  July  2023          CMPB   \n",
            "2    Company C 2023-07-17  July  2023          CMPC   \n",
            "3    Company D 2023-07-18  July  2023          CMPD   \n",
            "4    Company E 2023-07-19  July  2023          CMPE   \n",
            "\n",
            "                                  Array of Sentences  \n",
            "0  [ \\n \\nPage 1 of 24 \\n \\n \\n \\n“Kotak Mahindra...  \n",
            "1  [ \\n \\n \\n \\nPage 1 of 24 \\n \\n \\n \\n“Kotak Ma...  \n",
            "2  [ \\n \\nPage 1 of 19 \\n \\n \\nKotak Mahindra Ban...  \n",
            "3  [Page 1 of 24 \\n \\n \\n \\n \\nKotak Mahindra Ban...  \n",
            "4  [ \\n \\nPage 1 of 18 \\n \\n \\n“Kotak Mahindra Ba...  \n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "from sentence_transformers import SentenceTransformer\n",
        "import pandas as pd\n",
        "import pickle\n",
        "\n",
        "# Load the JSON data as DataFrame\n",
        "df = pd.read_json('transcripts_with_metadata.json')\n",
        "\n",
        "# Expand the 'Array of Sentences' column so each sentence gets its own row\n",
        "df = df.explode('Array of Sentences').reset_index(drop=True)\n",
        "\n",
        "# Rename the column for easier access\n",
        "df = df.rename(columns={'Array of Sentences': 'Sentence'})\n",
        "\n",
        "# Initialize the SBERT model\n",
        "model = SentenceTransformer('all-MiniLM-L6-v2')\n",
        "\n",
        "# Generate embeddings for each sentence\n",
        "df['Embedding'] = df['Sentence'].apply(lambda x: model.encode(x) if isinstance(x, str) else None)\n",
        "\n",
        "# Save the DataFrame as a pickle file\n",
        "with open('transcripts_with_embeddings.pkl', 'wb') as file:\n",
        "    pickle.dump(df, file)\n",
        "\n",
        "print(\"DataFrame with embeddings has been pickled and saved as transcripts_with_embeddings.pkl\")\n",
        "\n",
        "# Load the JSON data as DataFrame\n",
        "df2 = pd.read_json('transcripts_with_metadata2.json')\n",
        "\n",
        "# Expand the 'Array of Sentences' column so each sentence gets its own row\n",
        "df2 = df2.explode('Array of Sentences').reset_index(drop=True)\n",
        "\n",
        "# Rename the column for easier access\n",
        "df2 = df2.rename(columns={'Array of Sentences': 'Sentence'})\n",
        "\n",
        "# Initialize the SBERT model\n",
        "model = SentenceTransformer('all-MiniLM-L6-v2')\n",
        "\n",
        "# Generate embeddings for each sentence\n",
        "df2['Embedding'] = df2['Sentence'].apply(lambda x: model.encode(x) if isinstance(x, str) else None)\n",
        "\n",
        "# Save the DataFrame as a pickle file\n",
        "with open('transcripts_with_embeddings2.pkl', 'wb') as file:\n",
        "    pickle.dump(df2, file)\n",
        "\n",
        "print(\"DataFrame with embeddings has been pickled and saved as transcripts_with_embeddings2.pkl\")\n"
      ],
      "metadata": {
        "id": "FCvZ0zuHr1ux",
        "outputId": "e9288811-2515-4368-83b9-cf8a387ccd13",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "execution_count": 21,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "/usr/local/lib/python3.10/dist-packages/transformers/tokenization_utils_base.py:1601: FutureWarning: `clean_up_tokenization_spaces` was not set. It will be set to `True` by default. This behavior will be depracted in transformers v4.45, and will be then set to `False` by default. For more details check this issue: https://github.com/huggingface/transformers/issues/31884\n",
            "  warnings.warn(\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "DataFrame with embeddings has been pickled and saved as transcripts_with_embeddings.pkl\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "/usr/local/lib/python3.10/dist-packages/transformers/tokenization_utils_base.py:1601: FutureWarning: `clean_up_tokenization_spaces` was not set. It will be set to `True` by default. This behavior will be depracted in transformers v4.45, and will be then set to `False` by default. For more details check this issue: https://github.com/huggingface/transformers/issues/31884\n",
            "  warnings.warn(\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "DataFrame with embeddings has been pickled and saved as transcripts_with_embeddings2.pkl\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "from sklearn.decomposition import PCA\n",
        "import pandas as pd\n",
        "import pickle\n",
        "\n",
        "# Load the pickled DataFrame with embeddings\n",
        "with open('transcripts_with_embeddings.pkl', 'rb') as file:\n",
        "    df = pickle.load(file)\n",
        "\n",
        "# Extract the embeddings into a separate variable for PCA\n",
        "embeddings = df['Embedding'].tolist()\n",
        "\n",
        "# Initialize PCA to reduce to 2 dimensions\n",
        "pca = PCA(n_components=2)\n",
        "reduced_embeddings = pca.fit_transform(embeddings)\n",
        "\n",
        "# Add the reduced dimensions to the DataFrame\n",
        "df['D1'] = reduced_embeddings[:, 0]\n",
        "df['D2'] = reduced_embeddings[:, 1]\n",
        "\n",
        "# Save the updated DataFrame with dimensionality reduction to a new pickle file\n",
        "with open('transcripts_with_reduced_embeddings2.pkl', 'wb') as file:\n",
        "    pickle.dump(df2, file)\n",
        "\n",
        "print(\"Dimensionality reduction complete. DataFrame saved as transcripts_with_reduced_embeddings.pkl\")\n",
        "\n",
        "# Load the pickled DataFrame with embeddings\n",
        "with open('transcripts_with_embeddings2.pkl', 'rb') as file:\n",
        "    df2 = pickle.load(file)\n",
        "\n",
        "# Extract the embeddings into a separate variable for PCA\n",
        "embeddings = df2['Embedding'].tolist()\n",
        "\n",
        "# Initialize PCA to reduce to 2 dimensions\n",
        "pca = PCA(n_components=2)\n",
        "reduced_embeddings = pca.fit_transform(embeddings)\n",
        "\n",
        "# Add the reduced dimensions to the DataFrame\n",
        "df2['D3'] = reduced_embeddings[:, 0]\n",
        "df2['D4'] = reduced_embeddings[:, 1]\n",
        "\n",
        "# Save the updated DataFrame with dimensionality reduction to a new pickle file\n",
        "with open('transcripts_with_reduced_embeddings2.pkl', 'wb') as file:\n",
        "    pickle.dump(df, file)\n",
        "\n",
        "print(\"Dimensionality reduction complete. DataFrame saved as transcripts_with_reduced_embeddings2.pkl\")\n"
      ],
      "metadata": {
        "id": "dkvPJ4k9s1Md",
        "outputId": "d02da141-805c-4363-9412-19a6a6249e05",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "execution_count": 22,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Dimensionality reduction complete. DataFrame saved as transcripts_with_reduced_embeddings.pkl\n",
            "Dimensionality reduction complete. DataFrame saved as transcripts_with_reduced_embeddings2.pkl\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "!pip install transformers\n",
        "\n",
        "from transformers import pipeline\n",
        "import pandas as pd\n",
        "import pickle\n",
        "\n",
        "# Load the pickled DataFrame with reduced embeddings\n",
        "with open('transcripts_with_reduced_embeddings.pkl', 'rb') as file:\n",
        "    df = pickle.load(file)\n",
        "\n",
        "# Initialize FinBERT sentiment analysis pipeline\n",
        "sentiment_analyzer = pipeline('sentiment-analysis', model=\"ProsusAI/finbert\")\n",
        "\n",
        "# Define a function to get sentiment label\n",
        "def get_sentiment(sentence):\n",
        "    # Handle empty or NaN sentences\n",
        "    if pd.isna(sentence):\n",
        "        return None\n",
        "    result = sentiment_analyzer(sentence)\n",
        "    return result[0]['label']\n",
        "\n",
        "# Apply sentiment analysis to each sentence\n",
        "df['Sentiment'] = df['Sentence'].apply(get_sentiment)\n",
        "\n",
        "# Save the updated DataFrame with sentiment labels to a new pickle file\n",
        "with open('transcripts_with_sentiment.pkl', 'wb') as file:\n",
        "    pickle.dump(df, file)\n",
        "\n",
        "print(\"Sentiment classification complete. DataFrame saved as transcripts_with_sentiment.pkl\")\n",
        "\n",
        "# Load the pickled DataFrame with reduced embeddings\n",
        "with open('transcripts_with_reduced_embeddings2.pkl', 'rb') as file:\n",
        "    df2 = pickle.load(file)\n",
        "\n",
        "# Initialize FinBERT sentiment analysis pipeline\n",
        "sentiment_analyzer = pipeline('sentiment-analysis', model=\"ProsusAI/finbert\")\n",
        "\n",
        "# Define a function to get sentiment label\n",
        "def get_sentiment(sentence):\n",
        "    # Handle empty or NaN sentences\n",
        "    if pd.isna(sentence):\n",
        "        return None\n",
        "    result = sentiment_analyzer(sentence)\n",
        "    return result[0]['label']\n",
        "\n",
        "# Apply sentiment analysis to each sentence\n",
        "df2['Sentiment'] = df2['Sentence'].apply(get_sentiment)\n",
        "\n",
        "# Save the updated DataFrame with sentiment labels to a new pickle file\n",
        "with open('transcripts_with_sentiment2.pkl', 'wb') as file:\n",
        "    pickle.dump(df, file)\n",
        "\n",
        "print(\"Sentiment classification complete. DataFrame saved as transcripts_with_sentiment2.pkl\")\n"
      ],
      "metadata": {
        "id": "1LtDjzjItEeP",
        "outputId": "f80dfbea-f3ab-42b9-c961-a7262a16177f",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "execution_count": 23,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Requirement already satisfied: transformers in /usr/local/lib/python3.10/dist-packages (4.44.2)\n",
            "Requirement already satisfied: filelock in /usr/local/lib/python3.10/dist-packages (from transformers) (3.16.1)\n",
            "Requirement already satisfied: huggingface-hub<1.0,>=0.23.2 in /usr/local/lib/python3.10/dist-packages (from transformers) (0.24.7)\n",
            "Requirement already satisfied: numpy>=1.17 in /usr/local/lib/python3.10/dist-packages (from transformers) (1.26.4)\n",
            "Requirement already satisfied: packaging>=20.0 in /usr/local/lib/python3.10/dist-packages (from transformers) (24.1)\n",
            "Requirement already satisfied: pyyaml>=5.1 in /usr/local/lib/python3.10/dist-packages (from transformers) (6.0.2)\n",
            "Requirement already satisfied: regex!=2019.12.17 in /usr/local/lib/python3.10/dist-packages (from transformers) (2024.9.11)\n",
            "Requirement already satisfied: requests in /usr/local/lib/python3.10/dist-packages (from transformers) (2.32.3)\n",
            "Requirement already satisfied: safetensors>=0.4.1 in /usr/local/lib/python3.10/dist-packages (from transformers) (0.4.5)\n",
            "Requirement already satisfied: tokenizers<0.20,>=0.19 in /usr/local/lib/python3.10/dist-packages (from transformers) (0.19.1)\n",
            "Requirement already satisfied: tqdm>=4.27 in /usr/local/lib/python3.10/dist-packages (from transformers) (4.66.6)\n",
            "Requirement already satisfied: fsspec>=2023.5.0 in /usr/local/lib/python3.10/dist-packages (from huggingface-hub<1.0,>=0.23.2->transformers) (2024.10.0)\n",
            "Requirement already satisfied: typing-extensions>=3.7.4.3 in /usr/local/lib/python3.10/dist-packages (from huggingface-hub<1.0,>=0.23.2->transformers) (4.12.2)\n",
            "Requirement already satisfied: charset-normalizer<4,>=2 in /usr/local/lib/python3.10/dist-packages (from requests->transformers) (3.4.0)\n",
            "Requirement already satisfied: idna<4,>=2.5 in /usr/local/lib/python3.10/dist-packages (from requests->transformers) (3.10)\n",
            "Requirement already satisfied: urllib3<3,>=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests->transformers) (2.2.3)\n",
            "Requirement already satisfied: certifi>=2017.4.17 in /usr/local/lib/python3.10/dist-packages (from requests->transformers) (2024.8.30)\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "/usr/local/lib/python3.10/dist-packages/transformers/tokenization_utils_base.py:1601: FutureWarning: `clean_up_tokenization_spaces` was not set. It will be set to `True` by default. This behavior will be depracted in transformers v4.45, and will be then set to `False` by default. For more details check this issue: https://github.com/huggingface/transformers/issues/31884\n",
            "  warnings.warn(\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Sentiment classification complete. DataFrame saved as transcripts_with_sentiment.pkl\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "/usr/local/lib/python3.10/dist-packages/transformers/tokenization_utils_base.py:1601: FutureWarning: `clean_up_tokenization_spaces` was not set. It will be set to `True` by default. This behavior will be depracted in transformers v4.45, and will be then set to `False` by default. For more details check this issue: https://github.com/huggingface/transformers/issues/31884\n",
            "  warnings.warn(\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Sentiment classification complete. DataFrame saved as transcripts_with_sentiment2.pkl\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "import pickle\n",
        "\n",
        "# Load the DataFrame with sentiment labels\n",
        "with open('transcripts_with_sentiment.pkl', 'rb') as file:\n",
        "    df = pickle.load(file)\n",
        "\n",
        "# Ensure Date column is in datetime format\n",
        "df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
        "\n",
        "# Drop rows with invalid dates if any (optional, but may help if date parsing is inconsistent)\n",
        "df = df.dropna(subset=['Date'])\n",
        "\n",
        "# Extract the quarter and year from Date\n",
        "df['Quarter'] = df['Date'].dt.to_period('Q')\n",
        "\n",
        "# Filter for positive and negative sentiments only\n",
        "df_filtered = df[df['Sentiment'].isin(['positive', 'negative'])]\n",
        "\n",
        "# Calculate positive and negative counts per quarter\n",
        "sentiment_counts = df_filtered.groupby(['Quarter', 'Sentiment']).size().unstack(fill_value=0)\n",
        "\n",
        "# Calculate the positive sentiment polarity per quarter\n",
        "sentiment_counts['Positive Sentiment Polarity'] = sentiment_counts['positive'] / (sentiment_counts['positive'] + sentiment_counts['negative'])\n",
        "\n",
        "# Check the summary to ensure all quarters are captured\n",
        "print(sentiment_counts)\n",
        "\n",
        "# Load the DataFrame with sentiment labels\n",
        "with open('transcripts_with_sentiment2.pkl', 'rb') as file:\n",
        "    df2 = pickle.load(file)\n",
        "\n",
        "# Ensure Date column is in datetime format\n",
        "df2['Date'] = pd.to_datetime(df2['Date'], errors='coerce')\n",
        "\n",
        "# Drop rows with invalid dates if any (optional, but may help if date parsing is inconsistent)\n",
        "df2 = df2.dropna(subset=['Date'])\n",
        "\n",
        "# Extract the quarter and year from Date\n",
        "df2['Quarter'] = df2['Date'].dt.to_period('Q')\n",
        "\n",
        "# Filter for positive and negative sentiments only\n",
        "df2_filtered = df2[df2['Sentiment'].isin(['positive', 'negative'])]\n",
        "\n",
        "# Calculate positive and negative counts per quarter\n",
        "sentiment_counts2 = df2_filtered.groupby(['Quarter', 'Sentiment']).size().unstack(fill_value=0)\n",
        "\n",
        "# Calculate the positive sentiment polarity per quarter\n",
        "sentiment_counts2['Positive Sentiment Polarity'] = sentiment_counts2['positive'] / (sentiment_counts2['positive'] + sentiment_counts2['negative'])\n",
        "\n",
        "# Check the summary to ensure all quarters are captured\n",
        "print(sentiment_counts2)\n",
        "\n",
        "# Plot the positive sentiment polarity over time\n",
        "plt.figure(figsize=(10, 6))\n",
        "sentiment_counts['Positive Sentiment Polarity'].plot(kind='line', marker='o')\n",
        "sentiment_counts2['Positive Sentiment Polarity'].plot(kind='line', marker='o')\n",
        "plt.title('Quarterly Positive Sentiment Polarity Over Time')\n",
        "plt.xlabel('Quarter')\n",
        "plt.ylabel('Positive Sentiment Polarity')\n",
        "plt.grid()\n",
        "plt.show()\n",
        "\n"
      ],
      "metadata": {
        "id": "xtQA3HprvmQP",
        "outputId": "15f56709-79af-400f-dc44-f6c65f3375e1",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 746
        }
      },
      "execution_count": 24,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Sentiment  negative  positive  Positive Sentiment Polarity\n",
            "Quarter                                                   \n",
            "2023Q3          190       669                     0.778813\n",
            "Sentiment  negative  positive  Positive Sentiment Polarity\n",
            "Quarter                                                   \n",
            "2023Q3          190       669                     0.778813\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "/usr/local/lib/python3.10/dist-packages/pandas/plotting/_matplotlib/core.py:1561: UserWarning: Attempting to set identical low and high xlims makes transformation singular; automatically expanding.\n",
            "  ax.set_xlim(left, right)\n",
            "/usr/local/lib/python3.10/dist-packages/pandas/plotting/_matplotlib/core.py:1561: UserWarning: Attempting to set identical low and high xlims makes transformation singular; automatically expanding.\n",
            "  ax.set_xlim(left, right)\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 1000x600 with 1 Axes>"
            ],
            "image/png": "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UGZmptLS0nTXXXfJMIwiTzN75plnnNqXfv366cSJE1qzZo11bNGiRfL19dUjjzxy2ec5+vlWsM+uek8MHDiwWK6RatCggc11nQV9eu+99+qmm24qNF7Qa86+z4EbGeEKgCT7Q9P58+dlsVisN2hwxPfff68OHTqoXLlyqlSpkgIDA63XDBUVrux1+vRpnT171notxV9/BgwYIEk6derUNc3fo0cPeXt7a9GiRdY6v/jiC/Xu3dvuu3ItW7ZMiYmJSk5O1oEDB7Rz5041a9ZMkvTrr7+qRo0ahf7RV3A3sIJg0KNHD7Vq1UpPPfWUqlWrpp49e+rDDz80NWjdd999qlixovU0OunP05+aNGmievXqSfrzNCPDMDRu3LhCr3VcXJykwq/131WsWFFvvPGGjhw5Yr1TW3h4uGbOnKlXXnnlmrfz138sSlLlypUl/Xlq37WqWbNmoT/nihUrKjQ0tNDYX7d1LT3pivqlP//hnJiYqK+//lrr169XWlqa3nvvPfn6+ur06dPKyspSeHh4oefVr19f+fn5Onbs2GXnPnr0qPr376+AgACVL19egYGB1l86/P097eHh4fT1RR07dlT16tWt78f8/Hx98MEHeuihh64YnBz5fPvr+q56TxTXDYH+3lMFfXq1/jXjfQ7cqLjmCoCkP/9yrVGjhrZv337F9bZv366aNWtaf8N+uYCRl5dn8/jgwYNq3769br31Vk2ZMkWhoaHy8vLSl19+qalTpxYKCY7cGbDguX369FF0dHSR69x+++3XNH/lypX1wAMPaNGiRRo/frw++ugjZWdn29x97Wruueeeawqjf+Xr66tvv/1Wa9as0YoVK7Ry5UolJCTo3nvv1erVq035Lbi3t7e6deumjz/+WLNnz1Zqaqq+//57TZo0ybpOwWs9YsSIyx5ZrFu3rt3brFWrlp544gl1795dN998sxYtWqRXX331mrZzudfAcOIbRy4359W2dS096Yr6pT9v1tChQwen5ihKXl6eOnbsqDNnzuif//ynbr31VpUrV07Hjx9X//79C72nvb29nb7Nvbu7u6KiovT2229r9uzZ+v7773XixImrvh8rVqyo6tWr2/X5FhISYr2xiqveE6668+nfOdu/Zr3PgRsJ4QqAVdeuXTVv3jytW7dOrVu3LrT8u+++05EjRxQbG2sdq1y5ss6ePVto3b+fivX5558rOztbn332mc1vU/96eo89igpzgYGBqlChgvLy8lzyj8h+/frpoYce0g8//GC9mL5hw4amzF2rVi19/fXXOn/+vM1v3vfs2WNdXsDNzU3t27dX+/btNWXKFE2aNEljxozRmjVrLrvfjn7nTY8ePbRw4UIlJSVp9+7dMgzDevqTJOupY56enqa+1pUrV1adOnWsd19z1XaK6zuAXNWTZtcfGBgoPz8/7d27t9CyPXv2yM3NrdBRjgI7duzQvn37tHDhQvXr1886npiY6FRNV9vHfv366d///rc+//xzffXVVwoMDLTrFOIHHnhAb7/99lU/355++mmb8ZJ6T5Sk63GfgOLCaYEArEaMGCE/Pz89/fTT+v33322WnTlzRoMHD5a/v7/NnfPq1Kmjc+fO2fxGOCUlRR9//LHN8wt+U/rX38KfO3dOCxYscKjGcuXKFQpz7u7ueuSRR7Rs2TKbWyMXKOpW6o64//77VbVqVb3++utau3atQ0etrqZz587Ky8vTzJkzbcanTp0qi8Wi+++/X9Kfr//fNWnSRJKs1ykVpeD7c4oKwEXp0KGDAgIClJCQoISEBLVo0cLmFKagoCC1bdtW8+bNU0pKSqHnX+21/vnnn5WWllZo/Ndff9Uvv/xiPT3N2e1cTlH94wqu6sly5coVOt3OGe7u7urUqZM+/fRTm9t4p6amavHixWrdunWh2+P/9bmS7XvaMAxNnz7dqZoK7iJ4uT+n22+/XbfffrveeecdLVu2TD179rTri7BffPFF+fr6XvHzzc/Pz3o9YAFXvydKo+txn4DiwpErAFZ169bVe++9p169eqlRo0Z68sknVbt2bet1MX/88YeWLFli8w+Lnj176p///Ke6d++uoUOHKisrS3PmzFG9evVsLtjv1KmTvLy81LVrVz399NPKyMjQ22+/raCgoCL/8r6cZs2a6euvv9aUKVNUo0YN1a5dWxEREfrXv/6lNWvWKCIiQgMHDlSDBg105swZbd26VV9//XWR4cRenp6e6tmzp2bOnCl3d3f16tXrmuf6u65du6pdu3YaM2aMjhw5osaNG2v16tX69NNP9fzzz1tvNT9x4kR9++236tKli2rVqqVTp05p9uzZqlmzZpG/hS9QcG3X0KFDFRkZKXd3d5sbNBS1rw8//LCWLFmizMxMvfXWW4XWmTVrllq3bq1GjRpp4MCBuvnmm5WamqoNGzbot99+088//3zZ+RMTExUXF6cHH3xQd955p8qXL69Dhw5p/vz5ys7Otn7vlrPbudLrMWfOHL366quqW7eugoKCrN87ZjZX9GSzZs2UkJCg2NhY3XHHHSpfvry6du3qVJ2vvvqq9TvUnn32WXl4eGjevHnKzs62fudTUW699VbVqVNHI0aM0PHjx+Xv769ly5Y5fY2Yr6+vGjRooISEBNWrV08BAQG67bbbrLc9l/48ejVixAhJsvuXHbfccosWLlyo3r17F/n5lpaWpg8++MD6nivg6vdEaXU97hNQLIr57oQAyoAdO3YYUVFRRnBwsOHm5mZIMnx8fIxdu3YVuf7q1auN2267zfDy8jLCw8ON999/v8hbsX/22WfG7bffbvj4+BhhYWHG66+/bsyfP7/IWwh36dKlyG3t2bPHuOeeewxfX19Dks1t2VNTU40hQ4YYoaGhhqenpxEcHGy0b9/e+O9//2tdp+B20kuXLi00d1G3mi6wefNmQ5LRqVOnK7xytgpegyvdPt0wDOP8+fPG8OHDjRo1ahienp7GLbfcYrz55ps2txVPSkoyHnroIaNGjRqGl5eXUaNGDaNXr17Gvn37rOsUdSv2S5cuGc8995wRGBhoWCwWmz8TXeZ214mJiYYkw2KxGMeOHSuy5oMHDxr9+vUzgoODDU9PTyMkJMR44IEHjI8++uiK+3ro0CFj/Pjxxp133mkEBQUZHh4eRmBgoNGlSxfjm2++uabtFNyG+ocffrB5blF/nidPnjS6dOliVKhQwZBkvS375W7F3rBhw0I1Xa4/JRlDhgyxGXOmJ4v688zIyDCioqKMSpUqWW9nfyVXei/91datW43IyEijfPnyhp+fn9GuXTubW3j/tc6/vka//PKL0aFDB6N8+fJG1apVjYEDBxo///xzobqjo6ONcuXKFbntor7OYf369UazZs0MLy+vIvs0JSXFcHd3N+rVq3fVffu77du3G7169TKqV69u/TPp1auXzS3v/86s98TletUe13Irdnv7tKDX3nzzTYf3CYAti2E4eaUsgOvee++9p/79+6tPnz567733SrqcEvHzzz+rSZMmeu+999S3b9+SLge4oaWlpal69eoaP368xo0bV9LlAIAVpwUCuKp+/fopJSVFI0eOVM2aNW3ulHWjePvtt1W+fHk9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119/rXnz5un8+fOSpBMnTigjI8PU4gAAAACgrHD4yNWvv/6q++67T0ePHlV2drY6duyoChUq6PXXX1d2drbmzp3rijoBAAAAoFRz+MjVsGHD1Lx5c/3xxx/y9fW1jnfv3l1JSUmmFgcAAAAAZYXDR66+++47rV+/Xl5eXjbjYWFhOn78uGmFAQAAAEBZ4vCRq/z8fOXl5RUa/+2331ShQgVTigIAAACAssbhcNWpUydNmzbN+thisSgjI0NxcXHq3LmzmbUBAAAAQJnh8GmB//73vxUZGakGDRro4sWLioqK0v79+1W1alV98MEHrqgRAAAAAEo9h8NVzZo19fPPPyshIUE///yzMjIy9OSTT6p37942N7gAAAAAgBuJw+FKkjw8PNS7d2/17t3b7HoAAAAAoEyy+5qrffv2afPmzTZjSUlJateunVq0aKFJkyaZXhwAAAAAlBV2h6t//vOf+uKLL6yPDx8+rK5du8rLy0stW7bU5MmTbW50AQAAAAA3ErtPC/zxxx/10ksvWR8vWrRI9erV06pVqyRJt99+u/7zn//o+eefN71IAAAAACjt7D5ylZaWppo1a1ofr1mzRl27drU+btu2rY4cOWJqcQAAAABQVtgdrgICApSSkiLpzy8S/vHHH3XnnXdal+fk5MgwDPMrBAAAAIAywO5w1bZtW73yyis6duyYpk2bpvz8fLVt29a6/JdfflFYWJgLSgQAAACA0s/ua65ee+01dezYUbVq1ZK7u7tmzJihcuXKWZf/73//07333uuSIgEAAACgtLM7XIWFhWn37t3atWuXAgMDVaNGDZvlEyZMsLkmCwAAAABuJA59ibCHh4caN25c5LLLjQMAAADAjcDua64AAAAAAJdHuAIAAAAAExCuAAAAAMAEhCsAAAAAMME1havvvvtOffr0UcuWLXX8+HFJf96Kfd26daYWBwAAAABlhcPhatmyZYqMjJSvr6+2bdum7OxsSdK5c+c0adIk0wsEAAAAgLLA4XD16quvau7cuXr77bfl6elpHW/VqpW2bt16TUXMmjVLYWFh8vHxUUREhDZv3nzZddu2bSuLxVLop0uXLtZ1ilpusVj05ptvXlN9AAAAAHA1DoervXv36p577ik0XrFiRZ09e9bhAhISEhQbG6u4uDht3bpVjRs3VmRkpE6dOlXk+suXL1dKSor1Z+fO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vnx5PfLII0pNTbUu//nnn9WrVy+FhobK19dX9evX1/Tp023mSElJUVRUlOrVqyc3Nzc9//zzxbF7KAbF1UPLly9Xx44dFRgYKH9/f7Vs2VKrVq0qln2EaxVXD61bt06tWrVSlSpV5Ovrq1tvvVVTp04tln2EaxVXD/3V999/Lw8PDzVp0sRVu4ViUlz9k5ycLIvFUujn5MmTxbKfcJ3i/AzKzs7WmDFjVKtWLXl7eyssLEzz5883dX8IV05Yu3athgwZoo0bNyoxMVG5ubnq1KmTMjMzresMHz5cn3/+uZYuXaq1a9fqxIkTevjhh63Lt2zZoqCgIL3//vvatWuXxowZo1GjRmnmzJnWdbKzsxUYGKixY8eqcePGxbqPcK3i6qFvv/1WHTt21JdffqktW7aoXbt26tq1q7Zt21as+wvzFVcPlStXTjExMfr222+1e/dujR07VmPHjtV///vfYt1fmK+4eqjA2bNn1a9fP7Vv375Y9g+uVdz9s3fvXqWkpFh/goKCimU/4TrF2UOPP/64kpKSFB8fr7179+qDDz5QeHi4uTtkwDSnTp0yJBlr1641DMMwzp49a3h6ehpLly61rrN7925DkrFhw4bLzvPss88a7dq1K3JZmzZtjGHDhplaN0qP4uihAg0aNDAmTJhgTuEoNYqzh7p372706dPHnMJRari6h3r06GGMHTvWiIuLMxo3bmx6/ShZruqfNWvWGJKMP/74w2W1o3RwVQ999dVXRsWKFY3ff//ddcUbhsGRKxOdO3dOkhQQECDpzxSdm5urDh06WNe59dZbddNNN2nDhg1XnKdgDtxYiquH8vPzdf78efrsOlRcPbRt2zatX79ebdq0MalylBau7KEFCxbo0KFDiouLc0HlKA1c/RnUpEkTVa9eXR07dtT3339vcvUoDVzVQ5999pmaN2+uN954QyEhIapXr55GjBihCxcumFq/h6mz3cDy8/P1/PPPq1WrVrrtttskSSdPnpSXl5cqVapks261atUue47w+vXrlZCQoBUrVri6ZJQyxdlDb731ljIyMvT444+bVj9KXnH0UM2aNXX69GldunRJL7/8sp566inT9wMlx5U9tH//fo0cOVLfffedPDz458f1yJX9U716dc2dO1fNmzdXdna23nnnHbVt21abNm3SP/7xD5ftE4qXK3vo0KFDWrdunXx8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\n"
          },
          "metadata": {}
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "print(sentiment_summary)\n"
      ],
      "metadata": {
        "id": "uyHy3TJXwOiT",
        "outputId": "b182d4e6-b415-4586-ac45-9058b1952945",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "execution_count": 14,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Sentiment  negative  positive  Positive Sentiment Polarity\n",
            "Quarter                                                   \n",
            "2023Q3          190       669                     0.778813\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "print(df['Quarter'].unique())\n"
      ],
      "metadata": {
        "id": "Qan8sDoLwVTq",
        "outputId": "c5ded593-a45a-41ca-dd2c-63740d255634",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "execution_count": 15,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "<PeriodArray>\n",
            "['2023Q3']\n",
            "Length: 1, dtype: period[Q-DEC]\n"
          ]
        }
      ]
    }
  ],
  "metadata": {
    "colab": {
      "name": "Welcome To Colab",
      "provenance": [],
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
